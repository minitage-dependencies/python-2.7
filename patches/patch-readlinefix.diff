diff -ur o/Lib/rlcompleter.py n/Lib/rlcompleter.py
--- Lib/rlcompleter.py	2010-10-31 19:38:20.166172334 +0100
+++ Lib/rlcompleter.py	2010-10-31 19:47:34.506192450 +0100
@@ -72,25 +72,39 @@
             self.use_main_ns = 0
             self.namespace = namespace
 
+         # The cache of matches for a particular text fragment.
+        self.matches = []
+
     def complete(self, text, state):
         """Return the next possible completion for 'text'.
 
         This is called successively with state == 0, 1, 2, ... until it
-        returns None.  The completion should begin with 'text'.
+        returns None.  The completion should begin with 'text'.  Any text
+        with a period (.) will match as an attribute.  Any text that begins
+        with a single or double quote will match using file name expansion.
 
         """
         if self.use_main_ns:
             self.namespace = __main__.__dict__
 
         if state == 0:
-            if "." in text:
+        # For the first call with this set of text, compute all possible
+        # matches and store them in a member variable.  Subsequent calls
+        # will then iterate through this set of matches.
+            if ('"' in text) or ("'" in text):
+                self.matches = self.file_matches(text)
+            elif "." in text:
                 self.matches = self.attr_matches(text)
             else:
                 self.matches = self.global_matches(text)
-        try:
-            return self.matches[state]
-        except IndexError:
-            return None
+
+        if state < len(self.matches):
+            try:
+                return self.matches[state]
+            except IndexError:
+                return None
+        else:
+             return None
 
     def _callable_postfix(self, val, word):
         if hasattr(val, '__call__'):
@@ -129,10 +143,14 @@
 
         """
         import re
+        import types
+
+        # Setup the regular expression for attributes
         m = re.match(r"(\w+(\.\w+)*)\.(\w*)", text)
         if not m:
             return []
         expr, attr = m.group(1, 3)
+        # Group 1 is the class name, group 3 is the attribute text
         try:
             thisobject = eval(expr, self.namespace)
         except Exception:
@@ -142,10 +160,18 @@
         words = dir(thisobject)
         if "__builtins__" in words:
             words.remove("__builtins__")
+        # If this type is a class instance, use the __class__ member to
+        # get the dictionary of attributes
+        if type(thisobject) == types.InstanceType:
+            if hasattr(thisobject, '__class__'):
+                words.append('__class__')
+                words.extend(get_class_members(thisobject.__class__))
+        elif type(thisobject) == types.ClassType:
+            words.extend(get_class_members(thisobject))
+        else:
+            words.extend(dir(thisobject))
 
-        if hasattr(thisobject, '__class__'):
-            words.append('__class__')
-            words.extend(get_class_members(thisobject.__class__))
+        # Build the full matching text from class.attribute matches
         matches = []
         n = len(attr)
         for word in words:
@@ -155,6 +181,43 @@
                 matches.append(word)
         return matches
 
+    def file_matches(self, text):
+        """Compute matches when text is a file name.
+
+        Expects a leading single or double quote character in the text.
+        Will expand a leading ~ or ~user to a valid home directory.
+        Will expand a leading $VAR to an environment variable name."""
+        import glob
+        import os
+
+        # save the leading quote character so we can re-add it later
+        quote = text[0]
+        # strip the leading quote character
+        path = text[1:]
+
+        # expand a tilde (~) or a leading environment variable in the text
+        path = os.path.expanduser( path )
+        path = os.path.expandvars( path )
+
+        # append the any match character to send to the glob routine
+        path = path + "*"
+
+        # use the glob module to get all of the matches
+        rawMatches = glob.glob( path )
+
+        # re-prefix the text with the quoting character and append the correct
+        # terminating character depending on the type of match that was found.
+        # Directories are terminated with '/' and files with an ending quote.
+        matches = []
+        for entry in rawMatches:
+            if os.path.isdir( entry ):
+                matches.append( quote + entry + os.sep )
+            elif os.path.isfile( entry ):
+                matches.append( quote + entry + quote )
+            else:
+                matches.append( quote + entry )
+        return matches
+
 def get_class_members(klass):
     ret = dir(klass)
     if hasattr(klass,'__bases__'):
